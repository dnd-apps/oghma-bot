# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

directive @id(interface: Boolean) on FIELD_DEFINITION

directive @default(add: DgraphDefault, update: DgraphDefault) on FIELD_DEFINITION

directive @remoteResponse(name: String) on FIELD_DEFINITION

directive @cacheControl(maxAge: Int!) on QUERY

directive @generate(mutation: GenerateMutationParams, query: GenerateQueryParams, subscription: Boolean) on OBJECT | INTERFACE

directive @hasInverse(field: String!) on FIELD_DEFINITION

directive @search(by: [DgraphIndex!]) on FIELD_DEFINITION

directive @withSubscription on OBJECT | FIELD_DEFINITION | INTERFACE

directive @custom(dql: String, http: CustomHTTP) on FIELD_DEFINITION

directive @dgraph(pred: String, type: String) on OBJECT | FIELD_DEFINITION | INTERFACE

directive @lambda on FIELD_DEFINITION

directive @lambdaOnMutate(add: Boolean, delete: Boolean, update: Boolean) on OBJECT | INTERFACE

directive @secret(field: String!, pred: String) on OBJECT | INTERFACE

directive @auth(add: AuthRule, delete: AuthRule, password: AuthRule, query: AuthRule, update: AuthRule) on OBJECT | INTERFACE

directive @remote on OBJECT | INTERFACE | UNION | ENUM | INPUT_OBJECT

directive @cascade(fields: [String]) on FIELD

type AddNickGroupPayload {
    nickGroup(filter: NickGroupFilter, first: Int, offset: Int, order: NickGroupOrder): [NickGroup]
    numUids: Int
}

type AddUserNickPayload {
    numUids: Int
    userNick(filter: UserNickFilter, first: Int, offset: Int, order: UserNickOrder): [UserNick]
}

type DeleteNickGroupPayload {
    msg: String
    nickGroup(filter: NickGroupFilter, first: Int, offset: Int, order: NickGroupOrder): [NickGroup]
    numUids: Int
}

type DeleteUserNickPayload {
    msg: String
    numUids: Int
    userNick(filter: UserNickFilter, first: Int, offset: Int, order: UserNickOrder): [UserNick]
}

type MultiPolygon {
    polygons: [Polygon!]!
}

type Mutation {
    addNickGroup(input: [AddNickGroupInput!]!): AddNickGroupPayload
    addUserNick(input: [AddUserNickInput!]!, upsert: Boolean): AddUserNickPayload
    deleteNickGroup(filter: NickGroupFilter!): DeleteNickGroupPayload
    deleteUserNick(filter: UserNickFilter!): DeleteUserNickPayload
    updateNickGroup(input: UpdateNickGroupInput!): UpdateNickGroupPayload
    updateUserNick(input: UpdateUserNickInput!): UpdateUserNickPayload
}

type NickGroup {
    id: ID!
    name: String
    nickNames(filter: UserNickFilter, first: Int, offset: Int, order: UserNickOrder): [UserNick]!
    nickNamesAggregate(filter: UserNickFilter): UserNickAggregateResult
}

type NickGroupAggregateResult {
    count: Int
    nameMax: String
    nameMin: String
}

type Point {
    latitude: Float!
    longitude: Float!
}

type PointList {
    points: [Point!]!
}

type Polygon {
    coordinates: [PointList!]!
}

type Query {
    aggregateNickGroup(filter: NickGroupFilter): NickGroupAggregateResult
    aggregateUserNick(filter: UserNickFilter): UserNickAggregateResult
    getNickGroup(id: ID!): NickGroup
    getUserNick(user: String!): UserNick
    queryNickGroup(filter: NickGroupFilter, first: Int, offset: Int, order: NickGroupOrder): [NickGroup]
    queryUserNick(filter: UserNickFilter, first: Int, offset: Int, order: UserNickOrder): [UserNick]
}

type UpdateNickGroupPayload {
    nickGroup(filter: NickGroupFilter, first: Int, offset: Int, order: NickGroupOrder): [NickGroup]
    numUids: Int
}

type UpdateUserNickPayload {
    numUids: Int
    userNick(filter: UserNickFilter, first: Int, offset: Int, order: UserNickOrder): [UserNick]
}

type UserNick {
    nick: String!
    user: String!
}

type UserNickAggregateResult {
    count: Int
    nickMax: String
    nickMin: String
    userMax: String
    userMin: String
}

enum DgraphIndex {
    bool
    day
    exact
    float
    fulltext
    geo
    hash
    hour
    int
    int64
    month
    regexp
    term
    trigram
    year
}

enum HTTPMethod {
    DELETE
    GET
    PATCH
    POST
    PUT
}

enum Mode {
    BATCH
    SINGLE
}

enum NickGroupHasFilter {
    name
    nickNames
}

enum NickGroupOrderable {
    name
}

enum UserNickHasFilter {
    nick
    user
}

enum UserNickOrderable {
    nick
    user
}

"""

The DateTime scalar type represents date and time as a string in RFC3339 format.
For example: "1985-04-12T23:20:50.52Z" represents 20 minutes and 50.52 seconds after the 23rd hour of April 12th, 1985 in UTC.
"""
scalar DateTime

"""

The Int64 scalar type represents a signed 64‐bit numeric non‐fractional value.
Int64 can represent values in range [-(2^63),(2^63 - 1)].
"""
scalar Int64

input AddNickGroupInput {
    name: String
    nickNames: [UserNickRef]!
}

input AddUserNickInput {
    nick: String!
    user: String!
}

input AuthRule {
    and: [AuthRule]
    not: AuthRule
    or: [AuthRule]
    rule: String
}

input ContainsFilter {
    point: PointRef
    polygon: PolygonRef
}

input CustomHTTP {
    body: String
    forwardHeaders: [String!]
    graphql: String
    introspectionHeaders: [String!]
    method: HTTPMethod!
    mode: Mode
    secretHeaders: [String!]
    skipIntrospection: Boolean
    url: String!
}

input DateTimeFilter {
    between: DateTimeRange
    eq: DateTime
    ge: DateTime
    gt: DateTime
    in: [DateTime]
    le: DateTime
    lt: DateTime
}

input DateTimeRange {
    max: DateTime!
    min: DateTime!
}

input DgraphDefault {
    value: String
}

input FloatFilter {
    between: FloatRange
    eq: Float
    ge: Float
    gt: Float
    in: [Float]
    le: Float
    lt: Float
}

input FloatRange {
    max: Float!
    min: Float!
}

input GenerateMutationParams {
    add: Boolean
    delete: Boolean
    update: Boolean
}

input GenerateQueryParams {
    aggregate: Boolean
    get: Boolean
    password: Boolean
    query: Boolean
}

input Int64Filter {
    between: Int64Range
    eq: Int64
    ge: Int64
    gt: Int64
    in: [Int64]
    le: Int64
    lt: Int64
}

input Int64Range {
    max: Int64!
    min: Int64!
}

input IntFilter {
    between: IntRange
    eq: Int
    ge: Int
    gt: Int
    in: [Int]
    le: Int
    lt: Int
}

input IntRange {
    max: Int!
    min: Int!
}

input IntersectsFilter {
    multiPolygon: MultiPolygonRef
    polygon: PolygonRef
}

input MultiPolygonRef {
    polygons: [PolygonRef!]!
}

input NearFilter {
    coordinate: PointRef!
    distance: Float!
}

input NickGroupFilter {
    and: [NickGroupFilter]
    has: [NickGroupHasFilter]
    id: [ID!]
    name: StringTermFilter
    not: NickGroupFilter
    or: [NickGroupFilter]
}

input NickGroupOrder {
    asc: NickGroupOrderable
    desc: NickGroupOrderable
    then: NickGroupOrder
}

input NickGroupPatch {
    name: String
    nickNames: [UserNickRef]
}

input NickGroupRef {
    id: ID
    name: String
    nickNames: [UserNickRef]
}

input PointGeoFilter {
    near: NearFilter
    within: WithinFilter
}

input PointListRef {
    points: [PointRef!]!
}

input PointRef {
    latitude: Float!
    longitude: Float!
}

input PolygonGeoFilter {
    contains: ContainsFilter
    intersects: IntersectsFilter
    near: NearFilter
    within: WithinFilter
}

input PolygonRef {
    coordinates: [PointListRef!]!
}

input StringExactFilter {
    between: StringRange
    eq: String
    ge: String
    gt: String
    in: [String]
    le: String
    lt: String
}

input StringFullTextFilter {
    alloftext: String
    anyoftext: String
}

input StringHashFilter {
    eq: String
    in: [String]
}

input StringHashFilter_StringRegExpFilter {
    eq: String
    in: [String]
    regexp: String
}

input StringRange {
    max: String!
    min: String!
}

input StringRegExpFilter {
    regexp: String
}

input StringTermFilter {
    allofterms: String
    anyofterms: String
}

input UpdateNickGroupInput {
    filter: NickGroupFilter!
    remove: NickGroupPatch
    set: NickGroupPatch
}

input UpdateUserNickInput {
    filter: UserNickFilter!
    remove: UserNickPatch
    set: UserNickPatch
}

input UserNickFilter {
    and: [UserNickFilter]
    has: [UserNickHasFilter]
    nick: StringHashFilter_StringRegExpFilter
    not: UserNickFilter
    or: [UserNickFilter]
    user: StringHashFilter_StringRegExpFilter
}

input UserNickOrder {
    asc: UserNickOrderable
    desc: UserNickOrderable
    then: UserNickOrder
}

input UserNickPatch {
    nick: String
    user: String
}

input UserNickRef {
    nick: String
    user: String
}

input WithinFilter {
    polygon: PolygonRef!
}
